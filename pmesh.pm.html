

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pmesh.pm module &#8212; pmesh 0.1.51 documentation</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pmesh.testmpi module" href="pmesh.testmpi.html" />
    <link rel="prev" title="pmesh.particlemesh module" href="pmesh.particlemesh.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pmesh.testmpi.html" title="pmesh.testmpi module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pmesh.particlemesh.html" title="pmesh.particlemesh module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pmesh 0.1.51 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >pmesh</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="pmesh.html" accesskey="U">pmesh package</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="pmesh.particlemesh.html"
                        title="previous chapter">pmesh.particlemesh module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pmesh.testmpi.html"
                        title="next chapter">pmesh.testmpi module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pmesh.pm.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-pmesh.pm">
<span id="pmesh-pm-module"></span><h1>pmesh.pm module<a class="headerlink" href="#module-pmesh.pm" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pmesh.pm.BaseComplexField">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">BaseComplexField</code><span class="sig-paren">(</span><em>pm</em>, <em>base=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pmesh.pm.Field" title="pmesh.pm.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.pm.Field</span></code></a></p>
<dl class="method">
<dt id="pmesh.pm.BaseComplexField.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func</em>, <em>kind='wavenumber'</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a function to the field, in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first">func(k, y) where k is a list of k values that broadcasts into a full array.
value of k depends on kind. y is the corrsponding value of field.</p>
<p>y is the value of the field on the corresponding locations.</p>
<p class="last"><cite>k.normp(p=2, zeromode=1)</cite> would return <cite>|k|^2</cite> but set the zero mode (r == 0) to 1.</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The kind of value in k.
‘wavenumber’ means wavenumber from [- 2 pi / L * N / 2, 2 pi / L * N / 2).
‘circular’ means circular frequency from [- pi, pi).
‘index’ means [0, Nmesh )</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.BaseComplexField.c2r">
<code class="descname">c2r</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.c2r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.c2r" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.BaseComplexField.cdot">
<code class="descname">cdot</code><span class="sig-paren">(</span><em>other</em>, <em>metric=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.cdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.cdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Collective inner product between the independent modes of two Complex Fields.</p>
<p>The real part of the result is effectively self.c2r().cdot(other.c2r()) / Nmesh.prod().</p>
<p>FIXME: what does the imag part mean?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ComplexField</span></dt>
<dd><p class="first last">the other field for the inner product</p>
</dd>
<dt><strong>metric: callable</strong></dt>
<dd><p class="first last">metric(k) gives the metric of each mode.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.BaseComplexField.cdot_vjp">
<code class="descname">cdot_vjp</code><span class="sig-paren">(</span><em>v</em>, <em>metric=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.cdot_vjp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.cdot_vjp" title="Permalink to this definition">¶</a></dt>
<dd><p>backtrace gradient of cdot against other. This is a partial gradient.
This is currently only correct for cdot().real.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.BaseComplexField.cnorm">
<code class="descname">cnorm</code><span class="sig-paren">(</span><em>metric=None</em>, <em>norm=&lt;function BaseComplexField.&lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.cnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.cnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the norm collectively. The conjugates are added too.</p>
<p>This is effectively cdot(self).</p>
<p>NORM = Self-conj + lower + upper</p>
<div class="math">
<p><img src="_images/math/e63a2a8f8918cdf964c4c4b1919b8d75741fbf3c.png" alt="\sum_{m \in M} (self[m] * conjugate(other[m])
            +   conjugate(self[m]) * other[m])
             *  0.5  metric(k[m])"/></p>
</div></dd></dl>

<dl class="method">
<dt id="pmesh.pm.BaseComplexField.decompress_vjp">
<code class="descname">decompress_vjp</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.decompress_vjp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.decompress_vjp" title="Permalink to this definition">¶</a></dt>
<dd><p>Back-propagate the gradient of decompress from self to out.
If I change this mode in the .value array, how many modes are
actually changed in order to maintain the hermitian?</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.BaseComplexField.r2c_vjp">
<code class="descname">r2c_vjp</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#BaseComplexField.r2c_vjp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.BaseComplexField.r2c_vjp" title="Permalink to this definition">¶</a></dt>
<dd><p>Back-propagate the gradient of r2c to self.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pmesh.pm.ComplexField">
<code class="descclassname">pmesh.pm.</code><code class="descname">ComplexField</code><a class="headerlink" href="#pmesh.pm.ComplexField" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pmesh.pm.TransposedComplexField" title="pmesh.pm.TransposedComplexField"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.pm.TransposedComplexField</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pmesh.pm.Field">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">Field</code><span class="sig-paren">(</span><em>pm</em>, <em>base=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.lib.mixins.NDArrayOperatorsMixin</span></code></p>
<p>Base class for RealField and ComplexField.</p>
<p>It only supports those two subclasses.</p>
<dl class="method">
<dt id="pmesh.pm.Field.cast">
<code class="descname">cast</code><span class="sig-paren">(</span><em>type</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.cast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.cast" title="Permalink to this definition">¶</a></dt>
<dd><p>cast the field object to the given type, maintaining the meaning of the field.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.cgetitem">
<code class="descname">cgetitem</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.cgetitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.cgetitem" title="Permalink to this definition">¶</a></dt>
<dd><p>get a value from absolute index collectively.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.csetitem">
<code class="descname">csetitem</code><span class="sig-paren">(</span><em>index</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.csetitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.csetitem" title="Permalink to this definition">¶</a></dt>
<dd><p>get a value from absolute index collectively.
maintains Hermitian conjugation.
Returns the actually value that is set.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.preview">
<code class="descname">preview</code><span class="sig-paren">(</span><em>Nmesh=None</em>, <em>axes=None</em>, <em>resampler=None</em>, <em>method=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.preview"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.preview" title="Permalink to this definition">¶</a></dt>
<dd><p>gathers the mesh into as a numpy array, with
(reduced resolution).</p>
<p>The result is broadcast to all ranks, so this uses Nmesh.prod() per rank if all
axes are preserved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Nmesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, array_like, None</span></dt>
<dd><p class="first last">The desired Nmesh of the result. Be aware this function
allocates memory to hold A full Nmesh on each rank.
None will not resample Nmesh.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or None</span></dt>
<dd><p class="first last">list of axes to preserve.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string “upsample” or “downsample”, or None</span></dt>
<dd><p class="first last">upsample is like subsampling (faster) when Nmesh is lower resolution.
if None, use upsample for upsampling (Nmesh &gt;= self.Nmesh) and downsample for down sampling.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">An numpy array for the real density field.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.ravel">
<code class="descname">ravel</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.ravel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Ravel the field to ‘C’-order, partitioned by MPI ranks. Save the
result to flatiter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.flatiter, or Ellipsis for inplace</span></dt>
<dd><p class="first last">A flatiter to store the ‘C’ order. If not a flatiter, the .flat
attribute is used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numpy.flatiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the flatiter provided or created.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Set <cite>out</cite> to or Ellisps self.value for an ‘inplace’ ravel.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>out</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.resample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the Field by filling 0 or truncating modes.
Convert from and between Real/Complex automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Field</span></dt>
<dd><p class="first last">must be provided because it is a different PM. Can be RealField or (Tranposed/Untransposed)ComplexField</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pmesh.pm.Field.slabs">
<code class="descname">slabs</code><a class="headerlink" href="#pmesh.pm.Field.slabs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.sort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.unravel">
<code class="descname">unravel</code><span class="sig-paren">(</span><em>flatiter</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.unravel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.unravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsort c-ordered field values to the field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>flatiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.flatiter</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>self is updated. <cite>array</cite> does not have to be C_CONTIGUOUS flat iterator of array is used.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.Field.unsort">
<code class="descname">unsort</code><span class="sig-paren">(</span><em>flatiter</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#Field.unsort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.Field.unsort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pmesh.pm.ParticleMesh">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">ParticleMesh</code><span class="sig-paren">(</span><em>Nmesh</em>, <em>BoxSize=1.0</em>, <em>comm=None</em>, <em>np=None</em>, <em>dtype='f8'</em>, <em>plan_method='estimate'</em>, <em>resampler='cic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>ParticleMesh provides an interface to solver for forces
with particle mesh method</p>
<p>ParticleMesh does not deal with memory. Use RealField(pm) and ComplexField(pm)
to create memory buffers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (npx, npy)</span></dt>
<dd><p class="first last">The shape of the process mesh. This is the number of domains per direction.
The product of the items shall equal to the size of communicator.
For example, for 64 rank job, np = (8, 8) is a good choice.
Since for now only 3d simulations are supported, np must be of length-2.
The default is try to split the total number of ranks equally. (eg, for
a 64 rank job, default is (8, 8)</p>
</dd>
<dt><strong>comm</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPI.Comm</span></code></span></dt>
<dd><p class="first last">the MPI communicator, (default is MPI.COMM_WORLD)</p>
</dd>
<dt><strong>Nmesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of int</span></dt>
<dd><p class="first last">number of mesh points per side. The length decides the number of dimensions.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd><p class="first last">dtype of the buffers; if a complex dtype is given, the transforms will be c2c.
the type of fields are still ‘RealField’ and ‘ComplexField’, though the RealField
is actually made of complex numbers, and the ComplexField is no longer hermitian
compressed.</p>
</dd>
<dt><strong>BoxSize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">size of box</p>
</dd>
<dt><strong>domain</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="pmesh.domain.html#pmesh.domain.GridND" title="pmesh.domain.GridND"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.domain.GridND</span></code></a></span></dt>
<dd><p class="first last">domain decomposition (private)</p>
</dd>
<dt><strong>partition</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">pfft.Partition</span></code></span></dt>
<dd><p class="first last">domain partition (private)</p>
</dd>
<dt><strong>w</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">a list of the circular frequencies along each direction (-pi to pi)</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">a list of the wave numbers k along each direction (- pi N/ L to pi N/ L)</p>
</dd>
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">a list of the position along each direction (-L/2 to L/ 2). x is conjugate of k.</p>
</dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">a list of the mesh position along each direction (-N/2 to N/2). r is conjugate of w.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pmesh.pm.ParticleMesh.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>type=None</em>, <em>base=None</em>, <em>value=None</em>, <em>mode=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a field object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>type: string, or type</strong></dt>
<dd><p class="first last">‘real’, ‘complex’, ‘untransposedcomplex’,
RealField, ComplexField, TransposedComplexField, UntransposedComplexField</p>
</dd>
<dt><strong>base</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object, None</span></dt>
<dd><p class="first last">Reusing the base attribute (physical memory) of an existing field
object. Provide the attribute, not the field object. (<cite>obj._base</cite> not <cite>obj</cite>)</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, None</span></dt>
<dd><p class="first last">initialize the field with the values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.create_coords">
<code class="descname">create_coords</code><span class="sig-paren">(</span><em>field_type</em>, <em>return_indices=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.create_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.create_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Create coordinate arrays. If return_indices is True, return
the integer indices instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(when return_indices is False) list of arrays, broadcastable to the right shape of the field;</span></dt>
<dd><p class="first last">distance or wavenumber; between negative and positive.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(when return_indices is True) list of arrays, integers (ranging from 0 to Nmesh)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.decompose">
<code class="descname">decompose</code><span class="sig-paren">(</span><em>pos</em>, <em>smoothing=None</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.decompose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a domain decompose layout for particles at given
coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, ndim)</span></dt>
<dd><p class="first last">position of particles in simulation  unit</p>
</dd>
<dt><strong>smoothing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, float, array_like, string, or ResampleWindow</span></dt>
<dd><p class="first last">if given as a string or ResampleWindow, use 0.5 * support.
This is the size of the buffer region around a domain.
Default: None, use self.resampler</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:py:class:domain.Layout</span></dt>
<dd><p class="first last">layout that can be used to migrate particles and images</p>
</dd>
<dt><strong>to the correct MPI ranks that hosts the PM local mesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.downsample">
<code class="descname">downsample</code><span class="sig-paren">(</span><em>source</em>, <em>resampler=None</em>, <em>keep_mean=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.downsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample an image with the downsample method.</p>
<p>Downsampling paints the value of image at the pixel positions source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>source</strong> <span class="classifier-delimiter">:</span> <span class="classifier">RealField</span></dt>
<dd><p class="first last">the source image</p>
</dd>
<dt><strong>keep_mean</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">if True, conserves the mean rather than the total mass in the overlapped region.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new RealField.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note that kernels do not conserve total mass or mean exactly
by construction due to the sparse sampling, this is particularly bad
for lanzcos, db, and sym.</p>
<p>some tests are shown in <a class="reference external" href="https://github.com/rainwoodman/pmesh/pull/22">https://github.com/rainwoodman/pmesh/pull/22</a></p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.generate_uniform_particle_grid">
<code class="descname">generate_uniform_particle_grid</code><span class="sig-paren">(</span><em>shift=0.5</em>, <em>dtype=None</em>, <em>return_id=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.generate_uniform_particle_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.generate_uniform_particle_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>create uniform grid of particles, one per grid point, in BoxSize coordinate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, array_like</span></dt>
<dd><p class="first last">shifting the grid by this much relative to the size of each grid cell.
if array_like, per direction.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dtype, or None</span></dt>
<dd><p class="first last">dtype of the return value; default the same precision as the pm.</p>
</dd>
<dt><strong>return_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if True, return grid, id; id is the unique integer ID of this grid point.
it is between 0 and total number of grid points (exclusive).</p>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><p class="first last">grid : array_like (N, ndim)
id   : array_like (N)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.generate_whitenoise">
<code class="descname">generate_whitenoise</code><span class="sig-paren">(</span><em>seed</em>, <em>unitary=False</em>, <em>mean=0</em>, <em>type=&lt;class 'pmesh.pm.TransposedComplexField'&gt;</em>, <em>mode=None</em>, <em>base=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.generate_whitenoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.generate_whitenoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate white noise to the field with the given seed.</p>
<p>The scheme is supposed to be compatible with Gadget when the field is three-dimensional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The random seed</p>
</dd>
<dt><strong>mean</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the mean of the field</p>
</dd>
<dt><strong>unitary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True to generate a unitary white noise where the amplitude is fixed to 1 and
only the phase is random.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.mesh_coordinates">
<code class="descname">mesh_coordinates</code><span class="sig-paren">(</span><em>dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.mesh_coordinates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.mesh_coordinates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.paint">
<code class="descname">paint</code><span class="sig-paren">(</span><em>pos</em>, <em>hsml=None</em>, <em>mass=1.0</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>hold=False</em>, <em>gradient=None</em>, <em>layout=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.paint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.paint" title="Permalink to this definition">¶</a></dt>
<dd><p>Paint particles into the internal real canvas.</p>
<p>Transform the particle field given by pos and mass
to the overdensity field in fourier space and save
it in the internal storage.
A multi-linear CIC approximation scheme is used.</p>
<p>The function can be called multiple times:
the result is cummulative. In a multi-step simulation where
<a class="reference internal" href="#pmesh.pm.ParticleMesh" title="pmesh.pm.ParticleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleMesh</span></code></a> object is reused,  before calling
<a class="reference internal" href="#pmesh.pm.ParticleMesh.paint" title="pmesh.pm.ParticleMesh.paint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">paint()</span></code></a>, make sure the canvas is cleared with <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, ndim)</span></dt>
<dd><p class="first last">position of particles in simulation unit</p>
</dd>
<dt><strong>hsml</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, ndim)</span></dt>
<dd><p class="first last">scaling of the resampling window per particle; or None for the kernel intrinsic size.
(dimensionless)</p>
</dd>
<dt><strong>mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like (,)</span></dt>
<dd><p class="first last">mass of particles in simulation unit</p>
</dd>
<dt><strong>hold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, do not clear the current value in the field.</p>
</dd>
<dt><strong>gradient</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or integer</span></dt>
<dd><p class="first last">Direction to take the gradient of the window. The affine transformation
is properly applied.</p>
</dd>
<dt><strong>resampler: None or string</strong></dt>
<dd><p class="first last">type of window. Default : None, use self.pm.resampler</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout</span></dt>
<dd><p class="first last">domain decomposition to use for the readout. The position is first
routed to the target ranks and the result is reduced</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>the painter operation conserves the total mass. It is not the density.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.paint_jvp">
<code class="descname">paint_jvp</code><span class="sig-paren">(</span><em>pos</em>, <em>mass=1.0</em>, <em>v_pos=None</em>, <em>v_mass=None</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>gradient=None</em>, <em>layout=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.paint_jvp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.paint_jvp" title="Permalink to this definition">¶</a></dt>
<dd><p>A_q = W_qi M_i</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.paint_vjp">
<code class="descname">paint_vjp</code><span class="sig-paren">(</span><em>v</em>, <em>pos</em>, <em>mass=1.0</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>gradient=None</em>, <em>out_pos=None</em>, <em>out_mass=None</em>, <em>layout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.paint_vjp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.paint_vjp" title="Permalink to this definition">¶</a></dt>
<dd><p>back-propagate the gradient of paint from v.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout</span></dt>
<dd><p class="first last">domain decomposition to use for the readout. The position is first
routed to the target ranks and the result is reduced</p>
</dd>
<dt><strong>out_mass: array , None, or False</strong></dt>
<dd><p class="first">stored the backtraced gradient against mass</p>
<p class="last">if False, then the gradient against mass is not computed.
if None, a new RealField is created and returned</p>
</dd>
<dt><strong>out_pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, None or False</span></dt>
<dd><p class="first">store the backtraced graident against pos</p>
<p class="last">if False, then the gradient against pos is not computed.
if None, a new array is created and returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pmesh.pm.ParticleMesh.partition">
<code class="descname">partition</code><a class="headerlink" href="#pmesh.pm.ParticleMesh.partition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>Nmesh=None</em>, <em>BoxSize=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.reshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a reshaped ParticleMesh object, changing the resolution Nmesh, or even
dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Nmesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like or None</span></dt>
<dd><p class="first last">The new resolution</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A ParticleMesh of the given resolution and transpose property</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>Nmesh</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.resize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.respawn">
<code class="descname">respawn</code><span class="sig-paren">(</span><em>comm</em>, <em>np=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.respawn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.respawn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new ParticleMesh object with the same geometry but on a new communicator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>comm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">MPI.Comm</span></dt>
<dd><p class="first last">the new communicator</p>
</dd>
<dt><strong>np</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or int</span></dt>
<dd><p class="first last">the process mesh topology</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new ParticleMesh on the given communicator;</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Usually the communicator shall be a subcommunicator of self.comm, because otherwise
there is no way to correctly make a barrier.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.unravel">
<code class="descname">unravel</code><span class="sig-paren">(</span><em>type</em>, <em>flatiter</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.unravel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.unravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Unravel c-ordered field values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type to unravel into, subclass of Field. (ComplexField, RealField, TransposedComplexField, UntransposedComplexField)</span></dt>
<dd></dd>
<dt><strong>flatiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.flatiter</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">RealField or ComplexField</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>array</cite> does not have to be C_CONTIGUOUS, as the flat iterator of array is used.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.ParticleMesh.upsample">
<code class="descname">upsample</code><span class="sig-paren">(</span><em>source</em>, <em>resampler=None</em>, <em>keep_mean=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#ParticleMesh.upsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.ParticleMesh.upsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample an image with the upsample method.</p>
<p>Upsampling reads out the value of image at the pixel positions of the pm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>source</strong> <span class="classifier-delimiter">:</span> <span class="classifier">RealField</span></dt>
<dd><p class="first last">the source image</p>
</dd>
<dt><strong>keep_mean</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">if True, conserves the mean rather than the total mass in the overlapped region.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new RealField.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note that kernels do not conserve total mass or mean exactly
by construction due to the sparse sampling, this is particularly bad
for lanzcos, db, and sym.</p>
<p>some tests are shown in <a class="reference external" href="https://github.com/rainwoodman/pmesh/pull/22">https://github.com/rainwoodman/pmesh/pull/22</a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pmesh.pm.RealField">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">RealField</code><span class="sig-paren">(</span><em>pm</em>, <em>base=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pmesh.pm.Field" title="pmesh.pm.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.pm.Field</span></code></a></p>
<dl class="method">
<dt id="pmesh.pm.RealField.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func</em>, <em>kind='relative'</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a function to the field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first">func(r, y) where r is a list of r values that broadcasts into a full array.
value of r depends on kind.</p>
<p>y is the value of the field on the corresponding locations.</p>
<p class="last"><cite>r.normp(p=2, zeromode=1)</cite> would return <cite>|r|^2</cite> but set the zero mode (r == 0) to 1.</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The kind of value in r.
‘relative’ means distance from <cite>[-0.5 Boxsize, 0.5 BoxSize)</cite>.
‘index’ means <cite>[0, Nmesh )</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.c2r_vjp">
<code class="descname">c2r_vjp</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.c2r_vjp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.c2r_vjp" title="Permalink to this definition">¶</a></dt>
<dd><p>Back-propagate the gradient of c2r from self to out</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.cdot">
<code class="descname">cdot</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.cdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.cdot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.cmean">
<code class="descname">cmean</code><span class="sig-paren">(</span><em>dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.cmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.cmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Collective mean. Mean of the entire mesh. (Must be called collectively)</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.cnorm">
<code class="descname">cnorm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.cnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.cnorm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.csum">
<code class="descname">csum</code><span class="sig-paren">(</span><em>dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.csum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.csum" title="Permalink to this definition">¶</a></dt>
<dd><p>Collective mean. Sum of the entire mesh. (Must be called collectively)</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.ctranspose">
<code class="descname">ctranspose</code><span class="sig-paren">(</span><em>axes</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.ctranspose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.ctranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Collectively Transpose a RealField. This does not change the representation but actually
replaces the coordinates according to the new set of axes.</p>
<p class="rubric">Notes</p>
<p>This is currently implemented very inefficiently, with readout and paint operations.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.paint">
<code class="descname">paint</code><span class="sig-paren">(</span><em>pos</em>, <em>mass=1.0</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>hold=False</em>, <em>gradient=None</em>, <em>layout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.paint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.paint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.r2c">
<code class="descname">r2c</code><span class="sig-paren">(</span><em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.r2c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.r2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform real to complex transformation.</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.readout">
<code class="descname">readout</code><span class="sig-paren">(</span><em>pos</em>, <em>hsml=None</em>, <em>out=None</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>gradient=None</em>, <em>layout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.readout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.readout" title="Permalink to this definition">¶</a></dt>
<dd><p>Read out from real field at positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, ndim)</span></dt>
<dd><p class="first last">position of particles in simulation  unit</p>
</dd>
<dt><strong>hsml</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, ndim)</span></dt>
<dd><p class="first last">scaling of the resampling window per particle; or None for the kernel intrinsic size.
(dimensionless)</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, ndim)</span></dt>
<dd><p class="first last">output</p>
</dd>
<dt><strong>gradient</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or integer</span></dt>
<dd><p class="first last">Direction to take the gradient of the window. The affine transformation
is properly applied.</p>
</dd>
<dt><strong>resampler</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or string</span></dt>
<dd><p class="first last">type of window, default to self.pm.resampler</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout</span></dt>
<dd><p class="first last">domain decomposition to use for the readout. The position is first
routed to the target ranks and the result is reduced</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (,)</span></dt>
<dd><p class="first last">read out values from the real field.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.readout_jvp">
<code class="descname">readout_jvp</code><span class="sig-paren">(</span><em>pos</em>, <em>v_self=None</em>, <em>v_pos=None</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>gradient=None</em>, <em>layout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.readout_jvp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.readout_jvp" title="Permalink to this definition">¶</a></dt>
<dd><p>f_i = W_qi A_q</p>
</dd></dl>

<dl class="method">
<dt id="pmesh.pm.RealField.readout_vjp">
<code class="descname">readout_vjp</code><span class="sig-paren">(</span><em>pos</em>, <em>v</em>, <em>resampler=None</em>, <em>transform=None</em>, <em>gradient=None</em>, <em>out_self=None</em>, <em>out_pos=None</em>, <em>layout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#RealField.readout_vjp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.RealField.readout_vjp" title="Permalink to this definition">¶</a></dt>
<dd><p>back-propagate the gradient of readout.</p>
<p>Returns a tuple of (out_self, out_pos), one of both can be False depending
on the value of out_self and out_pos.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v: array</strong></dt>
<dd><p class="first last">current gradient over the result of readout.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout</span></dt>
<dd><p class="first last">domain decomposition to use for the readout. The position is first
routed to the target ranks and the result is reduced</p>
</dd>
<dt><strong>out_self: RealField, None, or False</strong></dt>
<dd><p class="first">stored the backtraced gradient against self</p>
<p class="last">if False, then the gradient against self is not computed.
if None, a new RealField is created and returned</p>
</dd>
<dt><strong>out_pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, None or False</span></dt>
<dd><p class="first">store the backtraced graident against pos</p>
<p class="last">if False, then the gradient against pos is not computed.
if None, a new array is created and returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pmesh.pm.TransposedComplexField">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">TransposedComplexField</code><span class="sig-paren">(</span><em>pm</em>, <em>base=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#TransposedComplexField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.TransposedComplexField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pmesh.pm.BaseComplexField" title="pmesh.pm.BaseComplexField"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.pm.BaseComplexField</span></code></a></p>
<p>A complex field with transposed representation. Faster for r2c/c2r but slower for
whitenoise</p>
</dd></dl>

<dl class="class">
<dt id="pmesh.pm.UntransposedComplexField">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">UntransposedComplexField</code><span class="sig-paren">(</span><em>pm</em>, <em>base=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#UntransposedComplexField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.UntransposedComplexField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pmesh.pm.BaseComplexField" title="pmesh.pm.BaseComplexField"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.pm.BaseComplexField</span></code></a></p>
<p>A complex field with untransposed representation. Faster for whitenoise,
slower for r2c and c2r.</p>
</dd></dl>

<dl class="function">
<dt id="pmesh.pm.build_index">
<code class="descclassname">pmesh.pm.</code><code class="descname">build_index</code><span class="sig-paren">(</span><em>indices</em>, <em>fullshape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#build_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.build_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a linear index array based on indices on an array of fullshape.
This is similar to numpy.ravel_multi_index.</p>
<p>index value of -1 will on any axes will be translated to -1 in the final.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><p class="first">indices : a tuple of index per dimension.</p>
<p class="last">fullshape : a tuple of the shape of the full array</p>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ind <span class="classifier-delimiter">:</span> <span class="classifier">a 3-d array of the indices of the coordinates in indices in</span></dt>
<dd>an array of size fullshape. -1 if any indices is -1.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pmesh.pm.exchange">
<code class="descclassname">pmesh.pm.</code><code class="descname">exchange</code><span class="sig-paren">(</span><em>layout</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#exchange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.exchange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pmesh.pm.is_inplace">
<code class="descclassname">pmesh.pm.</code><code class="descname">is_inplace</code><span class="sig-paren">(</span><em>out</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#is_inplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.is_inplace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pmesh.pm.reindex">
<code class="descclassname">pmesh.pm.</code><code class="descname">reindex</code><span class="sig-paren">(</span><em>Nsrc</em>, <em>Ndest</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#reindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the index in the frequency array for corresponding
k in Nsrc and composes Ndest</p>
<p>For those Ndest that doesn’t exist in Nsrc, return -1</p>
<p>Example:
&gt;&gt;&gt; reindex(8, 4)
&gt;&gt;&gt; array([0, 1, 2, 7])
&gt;&gt;&gt; reindex(4, 8)
&gt;&gt;&gt; array([ 0,  1,  2, -1, -1, -1,  -1,  3])</p>
</dd></dl>

<dl class="class">
<dt id="pmesh.pm.slab">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">slab</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=float</em>, <em>buffer=None</em>, <em>offset=0</em>, <em>strides=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#slab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.slab" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pmesh.pm.slabiter">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">slabiter</code><span class="sig-paren">(</span><em>field</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#slabiter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.slabiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pmesh.pm.xslab">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">xslab</code><a class="reference internal" href="_modules/pmesh/pm.html#xslab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.xslab" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
<dl class="method">
<dt id="pmesh.pm.xslab.normp">
<code class="descname">normp</code><span class="sig-paren">(</span><em>p=2</em>, <em>zeromode=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#xslab.normp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.xslab.normp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the p-norm of the vector, matching the broadcast shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">pnorm</p>
</dd>
<dt><strong>zeromode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, or None</span></dt>
<dd><p class="first last">set the zeromode to this value if not None.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pmesh.pm.xslabiter">
<em class="property">class </em><code class="descclassname">pmesh.pm.</code><code class="descname">xslabiter</code><span class="sig-paren">(</span><em>axis</em>, <em>nslabs</em>, <em>optx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pmesh/pm.html#xslabiter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pmesh.pm.xslabiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pmesh.pm.slabiter" title="pmesh.pm.slabiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pmesh.pm.slabiter</span></code></a></p>
<p>iterating will yield the sparse coordinates of a list of slabs</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pmesh.testmpi.html" title="pmesh.testmpi module"
             >next</a> |</li>
        <li class="right" >
          <a href="pmesh.particlemesh.html" title="pmesh.particlemesh module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pmesh 0.1.51 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >pmesh</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="pmesh.html" >pmesh package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Yu Feng.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>